[
  {
    "name": "Props",
    "isPractice": false,
    "index": 5,
    "description": "Ознакомительный урок 5",
    "content": "# Props\n\nProps представляет коллекцию значений, которые ассоциированы с компонентом. Эти значения позволяют создавать динамические компоненты, которые не зависят от жестко закодированных статических данных.\n\nФункциональный подход:\n\n```\nfunction Hello(props) {\n  return <div>\n            <p>Имя: {props.name}</p>\n            <p>Возраст: {props.age}</p>\n    </div>;\n}\n```\n\nПараметр props, который передается в функцию компонента, инкапсулирует свойства объекта. В частности, свойство name и age. При рендеринге мы можем создать набор компонентов Hello, но передать в них разные данные для name и age. И таким образом, получим набор однотипной разметки html, наполненной разными данными.\n\nИспользуем компонент Hello:\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>Hello React</title>\n</head>\n<body>\n    <div id=\"app\"></div>\n      \n    <script crossorigin src=\"https://unpkg.com/react@17/umd/react.production.min.js\"></script>\n    <script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.production.min.js\"></script>\n    <script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"></script>\n    <script type=\"text/babel\">\n        class Hello extends React.Component {\n            render() {\n              return <div>\n                          <p>Имя: {this.props.name}</p>\n                          <p>Возраст: {this.props.age}</p>\n                      </div>;\n            }\n          }\n          ReactDOM.render(\n              <Hello name=\"Tom\" age=\"33\" />,\n              document.getElementById(\"app\")\n          )\n    </script>\n</body>\n</html>\n```\n\nПри рендеринге React передает значения атрибутов в виде единого объекта \"props\". То есть значение из атрибута name=\"Tom\" перейдет в свойство props.name.\n\n![result] (https://metanit.com/web/react/pics/2.7.png)"
  },
  {
    "name": "События",
    "isPractice": false,
    "index": 6,
    "description": "Ознакомительный урок 6",
    "content": "# События\n\nОбработка событий элементов в React во многом похожа на обработку событий элементов DOM с помощью обычного JavaScript. В то же время есть небольшие отличия:\n\nСобытия в React используют camelCase (в стандартном html \"onclick\", в React - \"onClick\")\n\nВ JSX в обработчик события передается функция компонента, а не строка\n\nВ React можно применять разные способы определения и вызова событий. Возьмем простейшую задачу - обработка нажатия кнопки.\n\nРаспространенный подход заключается в установке привязки события в конструкторе компонента:\n\n```\nclass ClickButton extends React.Component {\n              \n    constructor(props) {\n        super(props);\n        this.press = this.press.bind(this);\n    }\n    press(){\n        console.log(this);\n        alert(\"Hello React!\")\n    }\n    render() {\n        return <button onClick={this.press}>Click</button>;\n    }\n}\n```\n\nЗдесь используется событие нажатия кнопки, которое задается через атрибут onClick (не onclick).\n\nЭтому атрибуту в качестве обработчика события передавалась функция this.press, которая определена в классе компонента. И при нажатии на кнопку будет вызываться функция press, которая с помощью функции alert отображает окно с некоторым уведомлением.\n\nГлавная сложность при использовании событий - это работа с ключевым словом this, которое указывает на текущий объект, в данном случае компонент. По умолчанию в функцию обработчика не передается текущий объект, поэтому this будет иметь значение undefined. И ни к каким свойствам и методам компонента через this мы обратиться не сможем. И чтобы в метод press корректно передавалась ссылка на текущий объект через this, в конструкторе класса прописывается вызов:\n\n```\nthis.press = this.press.bind(this);\n```\n\nИ также стоит отметить, что при определении конструктора компонента в нем должен вызываться конструктор базового класса, в который передается объект props.\n\nИспользуем компонент на веб-странице:\n\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>METANIT.COM</title>\n</head>\n<body>\n    <div id=\"app\"></div>\n       \n    <script crossorigin src=\"https://unpkg.com/react@17/umd/react.production.min.js\"></script>\n    <script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.production.min.js\"></script>\n    <script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"></script>\n    <script type=\"text/babel\">\n        class ClickButton extends React.Component {\n              \n           constructor(props) {\n               super(props);\n                  \n               this.press = this.press.bind(this);\n           }\n           press(){\n               console.log(this);\n               alert(\"Hello React!\")\n           }\n           render() {\n               return <button onClick={this.press}>Click</button>;\n           }\n       }\n          \n       ReactDOM.render(\n           <ClickButton />,\n           document.getElementById(\"app\")\n       )\n    </script>\n</body>\n</html>\nОбновление состояния и события в React\n![rebuild] (https://metanit.com/web/react/pics/2.8.png)\nОднако есть и другие способы определения и вызова события. Например, определение обработчика в виде публичного поля компонента, которое указывает на стрелочную функцию.\n\n```\nclass ClickButton extends React.Component {\n              \n    press = () => {\n        console.log(this);\n        alert(\"Hello React!\")\n    }\n    render() {\n        return <button onClick={this.press}>Click</button>;\n    }\n}\n```\n\nЛибо мы можем определить функцию обработчика события как обычный метод класса, а вызывать с помощью стрелочной функции:\n\n```\nclass ClickButton extends React.Component {\n              \n    press(){\n        console.log(this);\n        alert(\"Hello React!\");\n    }\n    render() {\n        return <button onClick={() => this.press()}>Click</button>;\n    }\n}\n```\n\nОднако в случае с использованием стрелочной функции есть вероятность столкнуться с проблемой производительности, если функция обработчика передается через свойства props вложенным компонентам. Так как обработчик события будет создаваться каждый раз заново при каждом рендеринге компонента, что может привести к дополнительному повторному рендерингу вложенных компонентов, без которого можно было бы обойтись. Поэтому использование конструктора является более предпочтительной практикой.\n\n## Получение информации о событии\nReact использует концепцию SyntheticEvent - специальных объектов, которые представляют собой обертки для объектов событий, передаваемых в функцию события. И используя такой объект, мы можем получить в обработчике события всю информацию о событии:\n\n```\nclass ClickButton extends React.Component {\n              \n    constructor(props) {\n        super(props);\n        this.press = this.press.bind(this);\n    }\n    press(e){\n        console.log(e); // выводим информацию о событии\n        alert(\"Hello React!\")\n    }\n    render() {\n        return <button onclick=\"{this.press}\">Click</button>;\n    }\n}\n```\nПараметр e - это и есть информация о событии, которая передается в обработчик системой и которую мы можем использовать при обработке.\n\n## Передача параметров в обработчик события\nЕсли необходимо передать в обработчик события некоторые аргументы, то в этом случае можно вызвать обработчик через стрелочную функцию:\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>METANIT.COM</title>\n</head>\n<body>\n    <div id=\"app\"></div>\n       \n    <script crossorigin src=\"https://unpkg.com/react@17/umd/react.production.min.js\"></script>\n    <script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.production.min.js\"></script>\n    <script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"></script>\n    <script type=\"text/babel\">\n        class PrintButton extends React.Component {\n              \n           constructor(props) {\n               super(props);\n                  \n               this.print = this.print.bind(this);\n           }\n           print(name, age){\n                console.log(`Name ${name}  Age: ${age}`);\n           }\n           render() {\n               return <div> \n                        <button onClick={() => this.print(\"Bob\", 23)}>Print Bob</button>\n                        <button onClick={() => this.print(\"Tom\", 36)}>Print Tom</button>\n                    </div>;\n           }\n       }\n          \n       ReactDOM.render(\n           <PrintButton />,\n           document.getElementById(\"app\")\n       )\n    </script>\n</body>\n</html>\n```\n\nПередача параметров в обработчик события в React\n![some] (https://metanit.com/web/react/pics/2.15.png)"
  },
  {
    "name": "State",
    "isPractice": false,
    "index": 7,
    "description": "State и его роль в компаненте",
    "content": "Объект state описывает внутреннее состояние компонента, он похож на props за тем исключением, что состояние определяется внутри компонента и доступно только из компонента.\n\nЕсли props представляет входные данные, которые передаются в компонент извне, то состояние хранит такие объекты, которые создаются в компоненте и полностью зависят от компонента.\n\nТакже в отличие от props значения в state можно изменять.\n\nИ еще важный момент - значения из state должны использоваться при рендеринге. Если какой-то объект не используется в рендерниге компонента, то нет смысла сохранять его в state.\n\nНередко state описывает какие-то визуальные свойства элемента, которые могут изменяться при взаимодействие с пользователем. Например, кнопку нажали, и соответственно можно изменить ее состояние - придать ей какой-то другой цвет, тень и так далее. Кнопку нажали повторно - можно вернуть исходное состояние.\n\nЕдинственное место, где можно установить объект state - это конструктор класса:\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>Hello React</title>\n</head>\n<body>\n    <div id=\"app\"></div>\n      \n    <script crossorigin src=\"https://unpkg.com/react@17/umd/react.production.min.js\"></script>\n    <script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.production.min.js\"></script>\n    <script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"></script>\n    <script type=\"text/babel\">\n        class Hello extends React.Component {\n            constructor(props) {\n                super(props);\n                this.state = {welcome: \"Добро пожаловать на сайт!\"};\n            }\n            render() {\n                return <h1>{this.state.welcome}</h1>;\n            }\n        }\n        ReactDOM.render(\n            <Hello />,\n            document.getElementById(\"app\")\n        )\n    </script>\n</body>\n</html>\n```\nПри определении конструктора компонента в нем должен вызываться конструктор базового класса, в который передается объект props.\n\nСостояние State в React\n![] (https://metanit.com/web/react/pics/2.5.png)\n## Обновление состояния\nДля обновления состояния вызывается функция setState():\n\n```\nthis.setState({welcome: \"Привет React\"});\n```\nИзменение состояния вызовет повторный рендеринг компонента, в соответствии с чем веб-страница будет обновлена.\n\nВ то же время не стоит изменять свойства состояния напрямую, например:\n\n```\nthis.state.welcome = \"Привет React\";\n```\nВ данном случае изменения повторного рендеринга компонента происходить не будет.\n\nПри этом нам не обязательно обновлять все его значения. В процессе работы программы мы можем обновить только некоторые свойства. Тогда необновленные свойства будут сохранять старые значения.\n\nПример обновления состояния:\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>Hello React</title>\n    <style>\n        button{\n            width: 100px;\n            height:30px;\n            border-radius: 4px;\n            margin:50px;\n        }\n        .on{\n            color:#666;\n            background-color: #ccc;\n        }\n        .off{\n            color:#888;\n            background-color: white;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"app\"></div>\n      \n    <script crossorigin src=\"https://unpkg.com/react@17/umd/react.production.min.js\"></script>\n    <script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.production.min.js\"></script>\n    <script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"></script>\n    <script type=\"text/babel\">\n        class ClickButton extends React.Component {\n             \n           constructor(props) {\n               super(props);\n               this.state = {class: \"off\", label: \"Нажми\"};\n                 \n               this.press = this.press.bind(this);\n           }\n           press(){\n               let className = (this.state.class===\"off\")?\"on\":\"off\";\n               this.setState({class: className});\n           }\n           render() {\n               return <button onClick={this.press} className={this.state.class}>{this.state.label}</button>;\n           }\n       }\n         \n       ReactDOM.render(\n           <ClickButton />,\n           document.getElementById(\"app\")\n       )\n    </script>\n</body>\n</html>\n```\nЗдесь определен компонент ClickButton, который по сути представляет кнопку. В состоянии кнопки хранится два свойства - надпись и класс. При нажатии на кнопку мы будем переключать с одного класса на другой. Событие нажатия кнопки через атрибут onClick связано с методом press(), в котором переключается класс кнопки.\n\n\nПри этом свойство state.label остается неизменным.\n\nОбновление состояния setState и события в React\n![async] (https://metanit.com/web/react/pics/2.18.png)\n## Асинхронное обновление\nПри наличии нескольких вызовов setState() React может объединять их в один общий пакет обновлений для увеличения производительности.\n\nТак как объекты this.props и this.state могут обновляться асинхронно, не стоит полагаться на значения этих объектов для вычисления состояния. Например:\n\n```\nthis.setState({\n  counter: this.state.counter + this.props.increment,\n});\n```\nДля обновления надо использовать другую версию функции setState(), которая в качестве параметра принимает функцию. Данная функция имеет два параметра: предыдущее состояние объекта state и объект props на момент применения обновления:\n\n```\nthis.setState(function(prevState, props) {\n  return {\n    counter: prevState.counter + props.increment\n  };\n});\n```\nНапример, определим два последовательных вызова setState():\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>METANIT.COM</title>\n</head>\n<body>\n    <div id=\"app\"></div>\n       \n    <script crossorigin src=\"https://unpkg.com/react@17/umd/react.production.min.js\"></script>\n    <script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.production.min.js\"></script>\n    <script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"></script>\n    <script type=\"text/babel\">\n        class ClickButton extends React.Component {\n              \n           constructor(props) {\n               super(props);\n               this.state = {counter: 0};\n               this.press = this.press.bind(this);\n           }\n           press(){\n               this.setState({counter: this.state.counter + parseInt(this.props.increment)});\n               this.setState({counter: this.state.counter + parseInt(this.props.increment)});\n           }\n           render() {\n               return <div>\n                            <button onClick={this.press}>Count</button>\n                            <div>Counter: {this.state.counter} <br />Increment: {this.props.increment}</div>\n                        </div>\n           }\n       }\n          \n       ReactDOM.render(\n           <ClickButton increment=\"1\" />,\n           document.getElementById(\"app\")\n       )\n    </script>\n</body>\n</html>\n```\nВ props определено свойство increment - значение, на которое будет увеличиваться свойство counter в state (this.setState({counter: this.state.counter + parseInt(this.props.increment)});). При чем при нажатии кнопки мы предполагаем, что функция setState() будет вызываться два раза, соответственно значение state.counter при нажатии кнопки должно увеличиваться на 2. Однако в реальности увеличение происходит лишь на 1:\n![] (https://metanit.com/web/react/pics/2.16.png)\n\nСинхронное обновление state in React\nТеперь изменим код, применив второй вариант функции setState():\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>METANIT.COM</title>\n</head>\n<body>\n    <div id=\"app\"></div>\n       \n    <script crossorigin src=\"https://unpkg.com/react@17/umd/react.production.min.js\"></script>\n    <script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.production.min.js\"></script>\n    <script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"></script>\n    <script type=\"text/babel\">\n        class ClickButton extends React.Component {\n              \n           constructor(props) {\n               super(props);\n               this.state = {counter: 0};\n                  \n               this.press = this.press.bind(this);\n           }\n           incrementCounter(prevState, props) {\n                  return {\n                    counter: prevState.counter + parseInt(props.increment)\n                  };\n            }\n           press(){\n               this.setState(this.incrementCounter);\n               this.setState(this.incrementCounter);\n           }\n           render() {\n               return <div>\n                        <button onClick={this.press}>Count</button>\n                        <div>Counter: {this.state.counter}<br /> Increment: {this.props.increment}</div>\n                </div>\n           }\n       }\n          \n       ReactDOM.render(\n           <ClickButton increment=\"1\" />,\n           document.getElementById(\"app\")\n       )\n    </script>\n</body>\n</html>\n```\nЧтобы избежать повторения, все действия по инкременту вынесены в отдельную функцию - incrementCounter, однако опять же функция setState() вызывается два раза. И теперь инкремент будет срабатывать два раза при однократном нажатии, собственно как и определено в коде и как и должно быть:\n\nАссинхронное обновление state in React\n![] (https://metanit.com/web/react/pics/2.17.png)\n"
  },
  {
    "name": "Знакомство с библиотекой",
    "isPractice": false,
    "index": 1,
    "description": "Ознакомительный урок 1",
    "content": "# Знакомство с библиотекой\n\nReact — JavaScript-библиотека с открытым исходным кодом для разработки пользовательских интерфейсов. React разрабатывается и поддерживается Facebook, Instagram и сообществом отдельных разработчиков и корпораций. React может использоваться для разработки одностраничных и мобильных приложений\n\nПолезные материалы по библиотеке: \n\n* [официальная документация] (https://ru.reactjs.org/docs/add-react-to-a-website.html)\n* [хороший сайт с примерами работы] (https://reactdev.ru/)\n* [большой сайт с множеством языков и тем] (https://metanit.com/web/react/)"
  },
  {
    "name": "Жизненный цикл компонента",
    "isPractice": false,
    "index": 8,
    "description": "Жизненный цикл компонента и то зачем оно вообще придуманно.",
    "content": "В процессе работы компонент проходит через ряд этапов жизненного цикла. На каждом из этапов вызывается определенная функция, в которой мы можем определить какие-либо действия:\n\n* constructor(props): конструктор, в котором происходит начальная инициализация компонента\n\n* static getDerivedStateFromProps(props, state): вызывается непосредственно перед рендерингом компонента. Этот метод не имеет доступа к текущему объекту компонента (то есть обратиться к объкту компоненту через this) и должен возвращать объект для обновления объекта state или значение null, если нечего обновлять.\n\n* render(): рендеринг компонента\n\n* componentDidMount(): вызывается после рендеринга компонента. Здесь можно выполнять запросы к удаленным ресурсам\n\n* componentWillUnmount(): вызывается перед удалением компонента из DOM\n\nКроме этих основных этапов или событий жизненного цикла, также имеется еще ряд функций, которые вызываются при обновлении состояния после начального рендеринга компонента, если в компоненте происходят обновления:\n\n* static getDerivedStateFromProps(props, state)\n\n* shouldComponentUpdate(nextProps, nextState): вызывается каждый раз при обновлении объекта props или state. В качестве параметра передаются новый объект props и state. Эта функция должна возвращать true (надо делать обновление) или false (игнорировать обновление). По умолчанию возвращается true. Но если функция будет возвращать false, то тем самым мы отключим обновление компонента, а последующие функции не будут срабатывать.\n\n* render(): рендеринг компонента (если shouldComponentUpdate возвращает true)\n\n* getSnapshotBeforeUpdate(prevProps, prevState): вызывается непосредственно перед компонента. Он позволяет компоненту получить информацию из DOM перед возможным обновлением. Возвращает в качестве значения какой-то отдельный аспект, который передается в качестве третьего параметра в метод componentDidUpdate() и может учитываться в componentDidUpdate при обновлении. Если нечего возвращать, то возвращается значение null\n\n* componentDidUpdate(prevProps, prevState, snapshot): вызывается сразу после обновления компонента (если shouldComponentUpdate возвращает true). В качестве параметров передаются старые значения объектов props и state. Третий параметр - значение, которое возвращает метод getSnapshotBeforeUpdate\n\nПрименим некоторые из событий жизненного цикла:\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>METANIT.COM</title>\n    <style>\n        button{\n            width: 100px;\n            height:30px;\n            border-radius: 4px;\n            margin:50px;\n        }\n        .on{\n            color:#666;\n            background-color: #ccc;\n        }\n        .off{\n            color:#888;\n            background-color: white;\n        }\n    </style>\n</head>\n<body>\n    <div id=\"app\"></div>\n       \n    <script crossorigin src=\"https://unpkg.com/react@17/umd/react.production.min.js\"></script>\n    <script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.production.min.js\"></script>\n    <script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"></script>\n    <script type=\"text/babel\">\n        class ClickButton extends React.Component {\n              \n           constructor(props) {\n               super(props);\n               this.state = {class: \"off\", label: \"Нажми\"};\n                  \n               this.press = this.press.bind(this);\n                  \n               console.log(\"constructor\");\n           }\n           static getDerivedStateFromProps(props, state) {\n                console.log(\"getDerivedStateFromProps()\");\n                return null;\n           }\n           componentDidMount(){\n               console.log(\"componentDidMount()\");\n           }\n           componentWillUnmount(){\n               console.log(\"componentWillUnmount()\");\n           }\n           shouldComponentUpdate(){\n               console.log(\"shouldComponentUpdate()\");\n               return true;\n           }\n           getSnapshotBeforeUpdate(prevProps, prevState) {\n              console.log(\"getSnapshotBeforeUpdate()\");\n              return null;\n          }\n           componentDidUpdate(){\n               console.log(\"componentDidUpdate()\");\n           }\n           press(){\n               var className = (this.state.class===\"off\")?\"on\":\"off\";\n               this.setState({class: className});\n           }\n           render() {\n               console.log(\"render()\");\n               return <button onClick={this.press} className={this.state.class}>{this.state.label}</button>;\n           }\n       }\n       ReactDOM.render(\n           <ClickButton />,\n           document.getElementById(\"app\")\n       )\n    </script>\n</body>\n</html>\n```\nПри загрузке компонента сработают сразу четыре этапа жизненного цикла компонента:\n![] (https://metanit.com/web/react/pics/2.9.png \"жизненный цикл\") *жизненный цикл*\n\nЖизненный цикл компонентов в React\nПри нажатии на кнопку сработает обработчик нажатия, который обновит объект state, что вызовет еще ряд функций жизненного цикла и повторный рендеринг:\n![] (https://metanit.com/web/react/pics/2.10.png \"жизненный цикл при перерендере\") *жизненный цикл при перерендере*\n"
  },
  {
    "name": "Первое приложение",
    "isPractice": false,
    "index": 2,
    "description": "Ознакомительный урок 2",
    "content": "# Первое приложение react\n\nReact - это библиотека JavaScript, которая используется для создания пользовательского интерфейса. React был создан компанией Facebook, а первый релиз библиотеки увидел свет в марте 2013 года. Текущей версий на данный момент (октябрь 2020 года) является версия React v17.0.\n\nПервоначально React предназначался для веба, для создания веб-сайтов, однако позже появилась платформа React Native, которая уже предназначалась для мобильных устройств.\n\nReact представляется идеальный инструмент для создания масштабируемых веб-приложений (в данном случае речь идет о фронтенде), особенно в тех ситуациях, когда приложение представляет SPA (одностраничное приложение).\n\nReact относительно прост в освоении, имеет понятный и лаконичный синтаксис.\n\n## Виртуальный DOM\n\nВся структура веб-страницы может быть представлена с помощью DOM (Document Object Model)- организация элементов html, которыми мы можем манипулировать, изменять, удалять или добавлять новые. Для взаимодействия с DOM применяется язык JavaScript. Однако когда мы пытаемся манипулировать html-элементами с помощью JavaScript, то мы можем столкнуться со снижением производительности, особенно при изменении большого количества элементов. А операции над элементами могут занять некоторое время, что неизбежно скажется на пользовательском опыте. Однако если бы мы работали из кода js с объектами JavaScript, то операции производились бы быстрее.\n\nДля решения проблемы производительности как раз и появилась концепция виртуального DOM.\n\nВиртуальный DOM представляет легковесную копию обычного DOM. И отличительной особенностью React является то, что данная библиотека работает именно с виртуальным DOM, а не обычным.\n\nЕсли приложению нужно узнать информацию о состоянии элементов, то происходит обращение к виртуальному DOM.\n\nЕсли необходимо изменить элементы веб-страницы, то изменения вначале вносятся в виртуальный DOM. Потом новое состояние виртуального DOM сравнивается с текущим состоянием. И если эти состояния различаются, то React находит минимальное количество манипуляций, которые необходимы до обновления реального DOM до нового состояния и производит их.\n\nВ итоге такая схема взаимодействия с элементами веб-страницы работает гораздо быстрее и эффективнее, чем если бы мы работали из JavaScript с DOM напрямую.\n\n## Другие особенности React\n\nДругой отличительной чертой библиотеки является концентрация на компонентах - мы можем создать отдельные компоненты и затем их легко переносить из проекта в проект.\n\nЕще одна особенность React - использование JSX. JSX представляет комбинацию кода JavaScript и XML и предоставляет простой и интуитивно понятный способ для определения кода визуального интерфейса.\n\n## Начало работы с React\n\nСоздадим простейшее приложение. Для этого определим на жестком диске для проекта новую папку, к примеру, я создал каталог C:\\react\\helloapp, и добавим в эту папку новый файл index.html со следующим кодом:\n\nindex.html \n```\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>Hello React</title>\n</head>\n<body>\n    <div id=\"app\"> </div>\n      \n    <script crossorigin src=\"https://unpkg.com/react@17/umd/react.production.min.js\"></script>\n    <script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.production.min.js\"></script>\n    <script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"></script>\n     \n   <script type=\"text/babel\">\n   // рендеринг элемента\n    ReactDOM.render(\n        <h1>Hello React</h1>,  // элемент, который мы хотим создать\n        document.getElementById(\"app\")    // где мы этот элемент хотим создать\n    )\n   </script>\n</body>\n</html>\n```\n\nДля рендеринга элемента на веб-странице применяется метод ReactDOM.render(), который принимает два параметра. Первый параметр представляет компонент, который мы хотим оторазить на веб-странице. В данном случае это обычный заголовок. В этот метод передается элемент, который надо добавить на веб-страницу. Второй параметр - это тот элемент веб-страницы, в котором будет производиться рендеринг компонента из первого параметра. В данном случае это элемент <div id=\"app\">. Этот как раз тот элемент, в который и будет помещаться заголовок.\n\nДля работы с React нам необходимы две библиотеки, которые мы получаем из CDN:\n\n```\n<script crossorigin src=\"https://unpkg.com/react@17/umd/react.production.min.js\"></script>\n<script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.production.min.js\"></script>\n```\n\nДля работы с кроссбраузерными запросами для данных скриптов установлен атрибут crossorigin.\n\nТакже для компиляции кода нам необходим компилятор Babel, который позволяет скомпилировать приложение при запуске в браузере.\n\n```\n<script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"></script>\n```\n\nТакже стоит отметить, что для следующего элемента script, который содержит основной код приложения, определен атрибут type=\"text/babel\". Этот атрибут и указывает, что данный код должен обрабатываться выше подключенным компилятором Babel.\n\nПеретащим страницу в браузер и увидим заголовок:\n\n![hello react page] (https://metanit.com/web/react/pics/1.1.png)\n"
  },
  {
    "name": "Компоненты",
    "isPractice": false,
    "index": 3,
    "description": "Ознакомительный урок 3 ",
    "content": "# lesson 3\n\nReactElement, который был рассмотрен в прошлой теме, позволяет создавать элементы, которые встраиваются на веб-страницу. Однако ReactElement плохо подходит для создания комплексной разметки HTML. Объекты ReactElement сложно использовать повторно в других аналогичных ситуациях, сложнее поддерживать.\n\nИ для решения этой проблемы в React используются компоненты. Компоненты проще обновлять и использовать повторно.\n\nКомпоненты аналогичны функциям JavaScript. Они хранят состояние с помощью свойств и возвращают элементы React, которые затем появляются на веб-странице.\n\n## Создание компонентов\nКомпоненты можно определить различными способами. Первый способ - функциональный. Например:\n\n```\nfunction Hello() {\n  return <h1>Привет, Eugene</h1>;\n}\n```\n\nЗдесь определяется компонент Hello. Название компонентов должно начинаться с заглавной буквы.\n\nВторой способ определения компонентов предполагает использование классов ES6:\n\n```\nclass Hello extends React.Component {\n  render() {\n    return <h1>Привет, Eugene</h1>;\n  }\n}\n```\n\nДля рендеринга компонента в классе компонента обязательно должен быть определен метод render(), который возвращает создаваемый элемент на JSX.\n\nТакже для определения мы можем использовать стрелочные функции (arrow functions):\n\n```\nvar Hello =() => {\n    return (<h1>Привет, Eugene</h1>);\n}\n```\n\nВ целом все описанные выше способы будут равноценны.\n\n## Применение компонентов\n\nИспользуем выше определенный компонент:\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>METANIT.COM</title>\n</head>\n<body>\n    <div id=\"app\"></div>\n       \n    <script crossorigin src=\"https://unpkg.com/react@17/umd/react.production.min.js\"></script>\n    <script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.production.min.js\"></script>\n    <script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"></script>\n    <script type=\"text/babel\">\n        class Hello extends React.Component {\n            render() {\n              return <h1>Привет, Eugene</h1>;\n            }\n          }\n          ReactDOM.render(\n              <Hello />,\n              document.getElementById(\"app\")\n          )\n    </script>\n</body>\n</html>\n```\n\n![result] (https://metanit.com/web/react/pics/2.3.png)\n\nЕсли рассмотреть поэтапно, то рендеринг компонента будет происходить следующим образом:\n\n* Для рендеринга компонента <Hello /> вызывается функция ReactDOM.render()\n\n* React вызывает компонент Hello\n\n* Компонент Hello возвращает элемент <h1>Привет, Eugene</h1>\n\n* React DOM обновляет стандартный DOM веб-страницы, чтобы она содержала элемент <h1>Привет, Eugene</h1>\n\nЗдесь важно отметить один момент. Вне зависимости от того, какой способ определения компонента мы используем, между названием класса/функции/стрелочной функции и элементом есть соответствие: класс/функция называется \"Hello\", и соответственно для рендеринга компонента применяется элемент <Hello />. При этом учитывается регистр. Причем можно использовать названия в элементов только в верхнем регистре (\"Hello\", но НЕ \"hello\"), поскольку элементы с называниями в нижнем регистре будут рассматриваться Reactом как валидные html-элементы."
  },
  {
    "name": "Введение в хуки",
    "isPractice": false,
    "index": 12,
    "description": "Хуки, их анатомия и применение",
    "content": "Хуки позволяют определять и использовать состояние и другие возможности React без создания классов. По сути хуки представляют функции, которые позволяют подключиться к состоянию и другим возможностям, которые есть в React.\n\nМы можем создавать свои хуки, однако React по умолчанию уже предоставляет ряд встроенных хуков:\n\n* useState: предназначен для управления состоянием компонентов\n\n* useEffect: предназначен для перехвата различного рода изменений в компонентах, которые нельзя обработать внутри компонентов\n\n* useContext: позволяет подписываться на контекст React\n\n* useReducer: позволяет управлять локальным состоянием сложных компонентов\n\n* useCallback: позволяет управлять функциями обратного вызова\n\n* useMemo: предназначен для управления мемоизированными (грубо говоря кэшированными) значениями\n\n* useRef: возвращать некоторое изменяемое значение, например, ссылку на html-элементы DOM, которыми затем можно управлять в коде JavaScript\n\n* useImperativeHandle: настраивает объект, который передается родительскому компоненту при использовании ref\n\n* useLayoutEffect: аналогичен хуку useEffect(), но вызывается синхронно после всех изменений в структуре DOM\n\n* useDebugValue: предназначен для отображения некоторого значения в целях отладки\n\n## Переход от классов к хукам\n\nРассмотрим простейший пример, как мы можем перейти от классов к хукам. Допустим, у нас есть следующий класс-компонент:\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>METANIT.COM</title>\n</head>\n<body>\n    <div id=\"app\"></div>\n        \n    <script crossorigin src=\"https://unpkg.com/react@17/umd/react.production.min.js\"></script>\n    <script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.production.min.js\"></script>\n    <script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"></script>\n    <script type=\"text/babel\">\n        class ClickButton extends React.Component {\n               \n           constructor(props) {\n               super(props);\n               this.state = {counter: 0};\n                   \n               this.press = this.press.bind(this);\n           }\n           incrementCounter(prevState, props) {\n                  return {\n                    counter: prevState.counter + props.increment\n                  };\n            }\n           press(){\n               this.setState(this.incrementCounter);\n           }\n           render() {\n               return <div>\n                        <button onClick={this.press}>Count</button>\n                        <div>Counter: {this.state.counter}<br /> Increment: {this.props.increment}</div>\n                </div>\n           }\n       }\n           \n       ReactDOM.render(\n           <ClickButton increment={2} />,\n           document.getElementById(\"app\")\n       )\n    </script>\n</body>\n</html>\n```\nЗдесь определен компонент ClickButton, который принимает через props некоторое значение increment. В конструкторе определяется состояние в виде переменной counter, которая равна 0. Кроме того, в классе определяется метод press(), в котором изменяется состояние компонента.\n\nДля изменения состояния вызывается другой метод - incrementCounter, который берет из props значение increment и использует его для увеличения значения переменной counter.\n\nВ коде класса-компонента определяется кнопка, по нажатию на которую как раз и вызывается метод press():\n\n```\n<button onClick={this.press}>Count</button>\n```\nВ итоге по нажатию на кнопку мы получим увеличение переменной counter:\n\nПереход от классов-компонентов к хукам в React\n\n![] (https://metanit.com/web/react/pics/6.2.png \"Пример функционального компанента\")\n*Пример функционального компанента*\n\nТеперь определим аналогичный компонент с использованием хуков:\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>METANIT.COM</title>\n</head>\n<body>\n    <div id=\"app\"></div>\n        \n    <script crossorigin src=\"https://unpkg.com/react@17/umd/react.production.min.js\"></script>\n    <script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.production.min.js\"></script>\n    <script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"></script>\n    <script type=\"text/babel\">\n        function ClickButtonHook(props){\n            const [count, setCount] = React.useState(0);\n            const press = function(){\n                setCount(count + props.increment);\n            };\n            return (<div>\n                    <button onClick={press}>Count</button>\n                    <div>Counter: {count}<br /> Increment: {props.increment}</div>\n                </div>);\n        }\n           \n       ReactDOM.render(\n           <ClickButtonHook increment={2} />,\n           document.getElementById(\"app\")\n       )\n    </script>\n</body>\n</html>\n```\nВ данном случае определен функциональный компонент ClickButtonHook, так как мы не можем использовать хуки в классах-компонентах, а только в функциях.\n\nВначале определяем переменные состояния:\n\n```\nconst [count, setCount] = React.useState(0);\n```\nВ данном случае определяются две переменных: count и setCount. Переменная count хранит состояние компонента, а переменная setCount позволяет изменять значение переменной count.\n\nВ функцию useState() передается число 0 - это то значение, которое по умолчанию получает переменная count.\n\nДля изменения состояния в компоненте определена функция press(), которая выполняет выражение setCount(count + props.increment); - к переменной count прибавляется значение increment из props. Это выражение (count + props.increment) и определяет новое значение переменной count. Таким образом, состояние компонента ClickButtonHook будет изменено.\n\nВ коде также определена кнопка, по нажатию на которую вызывается метод press(). В итоге мы получим ту же программу, но с использованием хуков. И как видно, этот код несколько короче, чем код класса-компонента.\n\nПодключение хуков\nВ примере выше библиотека React подключалась непосредственно на веб-страницу, где и определен весь код приложения. Однако если компоненты расположены в отдельных файлах, то мы можем импортировать хук useState (впрочем как и другие встроенные хуки) следующим образом:\n\n```\nimport React, { useState } from \"react\";\n \nfunction ClickButtonHook(props){\n    const [count, setCount] = React.useState(0);\n \n    const press= () => setCount(count + props.increment);\n    return <div>\n            <button onClick={press}>Count</button>\n            <div>Counter: {count}<br /> Increment: {props.increment}</div>\n    </div>;\n}\n```\nОграничения при использовании хуков\nХуки имеют ряд ограничений при определении и использовании:\n\nХуки вызываются только на верхнем уровне (top-level) компонента. Они НЕ вызываются внутри циклов, условных конструкций, внутри стандартных функций javascript.\n\nХуки можно вызывать только из функциональных компонентов React, либо из других хуков. Но их нельзя вызывать из классов-компонентов.\n\nФункциональные компоненты можно определять как обычные функции:\n\n```\nfunction ClickButtonHook(props){\n    const [count, setCount] = React.useState(0);\n \n    const press= () => setCount(count + props.increment);\n    return <div>\n            <button onClick={press}>Count</button>\n            <div>Counter: {count}<br /> Increment: {props.increment}</div>\n    </div>;\n}\n```\nЛибо в виде стрелочных функций:\n\n```\nconst ClickButtonHook = (props)=>{\n    const [count, setCount] = React.useState(0);\n \n    const press= () => setCount(count + props.increment);\n    return <div>\n            <button onClick={press}>Count</button>\n            <div>Counter: {count}<br /> Increment: {props.increment}</div>\n    </div>;\n}\n```"
  },
  {
    "name": "Refs и доступ к структуре dom",
    "isPractice": false,
    "index": 11,
    "description": "Refs и доступ к структуре dom",
    "content": "В прошлой теме рассматривалось, как обновлять значение при вводе с помощью обработчика события change. Но есть и другой способ получения введенных данных, который заключается в использовании атрибута ref.\n\nАтрибут ref может применяться к любому элементу веб-страницы. После установки атрибута в коде React мы сможем ссылать на этот элемент. Например:\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>Формы в React</title>\n</head>\n<body>\n    <div id=\"app\"></div>\n         \n    <script crossorigin src=\"https://unpkg.com/react@17/umd/react.production.min.js\"></script>\n    <script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.production.min.js\"></script>\n    <script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"></script>\n         \n    <script type=\"text/babel\">\n    class UserForm extends React.Component {\n        constructor(props) {\n            super(props);\n            this.handleSubmit = this.handleSubmit.bind(this);\n            this.nameField = React.createRef();\n        }\n        handleSubmit(e) {\n            e.preventDefault();\n            console.log(this.nameField);\n            var name = this.nameField.current.value;\n            alert(\"Имя: \" + name);\n        }\n        render() {\n            return <form onSubmit={this.handleSubmit}>\n                        <input ref={this.nameField} />\n                        <input type=\"submit\" value=\"Отправить\" />\n                    </form>;\n      }\n    }\n    ReactDOM.render(\n        <UserForm />,\n        document.getElementById(\"app\")\n    )\n    </script>\n</body>\n</html>\n```\nДля создания ссылок ref применяется функция React.createRef(). В данном случае это происходит в конструкторе:\n\n![] (https://metanit.com/web/react/pics/3.3.png \"Результат в браузере\")\n*Результат в браузере*\n\n```\nthis.nameField = React.createRef();\n```\nЗатем созданную ссылку можно прикрепить к какому-нибудь элементу на html-странице. Для этого применяется применяется атрибут ref, которому в фигурных скобках передается ссылка.\n\n```\n<input ref={this.nameField} />\n```\nДалее в коде мы сможем ссылаться на этот элемент, в том числе получать его значения, с помощью выражения this.nameField.current.\n\nRef в React\nЕдинственный минус в этом случае, то что мы не можем установить значение по умолчанию с помощью стандартного атрибута value: при использовании атрибута value опять же придется задавать обработчик события change, как в прошлой теме. Альтернативой данному подходу служит применение специального атрибута defaultValue, который задает для поля ввода значение по умолчанию:\n\n```\nrender() {\n    return <form onSubmit={this.handleSubmit}>\n                <input defaultValue=\"Tom\" ref={this.nameField}  />\n                <input type=\"submit\" value=\"Отправить\" />\n            </form>;\n}\n```\n## Рефакторинг формы\nВозьмем форму из прошлой темы и разделим ее на компоненты с применением атрибута ref:\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>Формы в React</title>\n</head>\n<body>\n    <div id=\"app\"></div>\n       \n    <script crossorigin src=\"https://unpkg.com/react@17/umd/react.production.min.js\"></script>\n    <script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.production.min.js\"></script>\n    <script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"></script>\n       \n    <script type=\"text/babel\">\n    class NameField extends React.Component {\n        constructor(props) {\n            super(props);\n            var isValid = this.validate(props.value);\n            this.state = {value: props.value, valid: isValid};\n            this.onChange = this.onChange.bind(this);\n        }\n        validate(val){\n            return val.length>2;\n        }\n        onChange(e) {\n            var val = e.target.value;\n            var isValid = this.validate(val);\n            this.setState({value: val, valid: isValid});\n        }\n        render() {\n            var color = this.state.valid===true?\"green\":\"red\";\n            return <p>\n                <label>Имя:</label><br />\n                <input type=\"text\" value={this.state.value} onChange={this.onChange} style={{borderColor:color}} />\n            </p>;\n        }   \n    }\n    class AgeField extends React.Component {\n        \n        constructor(props) {\n            super(props);\n            var isValid = this.validate(props.value);\n            this.state = {value: props.value, valid: isValid};\n            this.onChange = this.onChange.bind(this);\n        }\n        validate(val){\n            return val>=0;\n        }\n        onChange(e) {\n            var val = e.target.value;\n            var isValid = this.validate(val);\n            this.setState({value: val, valid: isValid});\n        }\n        render() {\n            var color = this.state.valid===true?\"green\":\"red\";\n            return <p>\n                <label>Возраст:</label><br />\n                <input type=\"number\" value={this.state.value} onChange={this.onChange} style={{borderColor:color}} />\n            </p>;\n        }   \n    }\n      \n    class UserForm extends React.Component {\n        constructor(props) {\n            super(props);\n            this.handleSubmit = this.handleSubmit.bind(this);\n            this.nameField = React.createRef();\n            this.ageField = React.createRef();\n        }\n        handleSubmit(e) {\n            e.preventDefault();\n            var name = this.nameField.current.state.value;\n            var age = this.ageField.current.state.value;\n            if(this.nameField.current.state.valid && this.ageField.current.state.valid){\n                alert(\"Имя: \" + name + \" Возраст: \" + age);\n            }\n        }\n  \n        render() {\n            return (\n                <form onSubmit={this.handleSubmit}>\n                <NameField value=\"\" ref={this.nameField} />\n                <AgeField value=\"5\" ref={this.ageField} />\n                <input type=\"submit\" value=\"Отправить\" />\n            </form>\n        );\n      }\n    }\n    ReactDOM.render(\n        <UserForm />,\n        document.getElementById(\"app\")\n    )\n    </script>\n</body>\n</html>\n```\nВначале в конструкторе компонента UserForm создаем две ссылки:\n\n```\nthis.nameField = React.createRef();\nthis.ageField = React.createRef();\n```\nЗатем для обращения к вложенным компонентам у каждого устанавливается атрибут ref:\n\n```\n<NameField value=\"\" ref={this.nameField} />\n<AgeField value=\"5\" ref={this.ageField} />\n```\nИ в дальнейшем по значению атрибута мы можем ссылаться на эти компоненты, в том числе получать их состояние:\n\n```\nhandleSubmit(e) {\n    e.preventDefault();\n    var name = this.nameField.current.state.value;\n    var age = this.ageField.current.state.value;\n    if(this.nameField.current.state.valid && this.ageField.current.state.valid){\n        alert(\"Имя: \" + name + \" Возраст: \" + age);\n    }\n}\n```\n"
  },
  {
    "name": "Валидация форм",
    "isPractice": false,
    "index": 10,
    "description": "Валидация форм и работы с данными пользователя",
    "content": "Реализации валидации форм в React.js предусматривает проверку их введенных значений, и если эти значения сооветстуют требованиям, тогда происходит изменение состояния компонента. Так, определим следующую страницу index.html:\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>Формы в React</title>\n</head>\n<body>\n    <div id=\"app\"></div>\n        \n    <script crossorigin src=\"https://unpkg.com/react@17/umd/react.production.min.js\"></script>\n    <script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.production.min.js\"></script>\n    <script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"></script>\n        \n    <script type=\"text/babel\">\n    class UserForm extends React.Component {\n      constructor(props) {\n        super(props);\n        var name = props.name;\n        var nameIsValid = this.validateName(name);\n        var age = props.age;\n        var ageIsValid = this.validateAge(age);\n        this.state = {name: name, age: age, nameValid: nameIsValid, ageValid: ageIsValid};\n   \n        this.onNameChange = this.onNameChange.bind(this);\n        this.onAgeChange = this.onAgeChange.bind(this);\n        this.handleSubmit = this.handleSubmit.bind(this);\n      }\n        validateAge(age){\n            return age>=0;\n        }\n        validateName(name){\n            return name.length>2;\n        }\n        onAgeChange(e) {\n            var val = e.target.value;\n            var valid = this.validateAge(val);\n            this.setState({age: val, ageValid: valid});\n        }\n        onNameChange(e) {\n            var val = e.target.value;\n            console.log(val);\n            var valid = this.validateName(val);\n            this.setState({name: val, nameValid: valid});\n        }\n   \n        handleSubmit(e) {\n            e.preventDefault();\n            if(this.state.nameValid ===true && this.state.ageValid===true){\n                alert(\"Имя: \" + this.state.name + \" Возраст: \" + this.state.age);\n            }\n        }\n   \n        render() {\n            // цвет границы для поля для ввода имени\n            var nameColor = this.state.nameValid===true?\"green\":\"red\";\n            // цвет границы для поля для ввода возраста\n            var ageColor = this.state.ageValid===true?\"green\":\"red\";\n            return (\n                <form onSubmit={this.handleSubmit}>\n                    <p>\n                        <label>Имя:</label><br />\n                        <input type=\"text\" value={this.state.name} \n                            onChange={this.onNameChange} style={{borderColor:nameColor}} />\n                    </p>\n                    <p>\n                        <label>Возраст:</label><br />\n                        <input type=\"number\" value={this.state.age} \n                            onChange={this.onAgeChange}  style={{borderColor:ageColor}} />\n                    </p>\n                    <input type=\"submit\" value=\"Отправить\" />\n                </form>\n            );\n        }\n    }\n    ReactDOM.render(\n        <UserForm name=\"\" age=\"0\" />,\n        document.getElementById(\"app\")\n    )\n    </script>\n</body>\n</html>\n```\nЗдесь добавлено поле для ввода возраста. Дополнительные значения nameValid и ageValid позволяют установить корректность введенных имени и возраста соответственно. Эти значения понадобятся для стилизации полей. Так, если введенное значение некорректно, то поле ввода будет иметь красную границу, иначе зеленую.\n\n```\nvar nameColor = this.state.nameValid===true?\"green\":\"red\";\nvar ageColor = this.state.ageValid===true?\"green\":\"red\";\n```\nПри определении поля ввода каждое поле связывается с определенным значением в state:\n\n```\n<input type=\"text\" value={this.state.name} onChange={this.onNameChange} style={{borderColor:nameColor}} />\n<input type=\"number\" value={this.state.age} onChange={this.onAgeChange}  style={{borderColor:ageColor}} />\n```\nИ для каждого поля ввода определен свой обработчик onChange, в котором происходит валидация и изменение введенного значения:\n\n![] (https://metanit.com/web/react/pics/3.1.png \"валидный вариант\") *валидный вариант*\n![] (https://metanit.com/web/react/pics/3.2.png \"не валидный вариант\") *не валидный вариант*"
  },
  {
    "name": "Примеры кода",
    "isPractice": true,
    "index": 4,
    "description": "Ознакомительный урок 4",
    "content": "# lesson 4\n\nПопробуйте создать компонент который будет выводить на экран вот такой элемент: \n\n![html code] (https://html5css.ru/html/img_chrome.png)\n\n<hr />\n\nРезультат запакуйте в архив и отправьте на проверку"
  },
  {
    "name": "Формы и управление состоянием",
    "isPractice": false,
    "index": 9,
    "description": "Формы и управление состоянием полей ввода.",
    "content": "Хотя в React мы можем использовать все стандартные элементы форм, которые есть в html, однако здесь эти элементы приобретают дополнительные возможности. Рассмотрим, как работать с формами в React.\n\nОпределим на веб-странице следующий код:\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>Формы в React</title>\n</head>\n<body>\n    <div id=\"app\"></div>\n        \n    <script crossorigin src=\"https://unpkg.com/react@17/umd/react.production.min.js\"></script>\n    <script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.production.min.js\"></script>\n    <script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"></script>\n        \n    <script type=\"text/babel\">\n    class UserForm extends React.Component {\n      constructor(props) {\n        super(props);\n        this.state = {name: \"\"};\n   \n        this.onChange = this.onChange.bind(this);\n        this.handleSubmit = this.handleSubmit.bind(this);\n      }\n      onChange(e) {\n        var val = e.target.value;\n        this.setState({name: val});\n    }\n   \n      handleSubmit(e) {\n        e.preventDefault();\n        alert(\"Имя: \" + this.state.name);\n      }\n   \n      render() {\n        return (\n            <form onSubmit={this.handleSubmit}>\n                <p>\n                    <label>Имя:</label><br />\n                    <input type=\"text\" value={this.state.name} onChange={this.onChange}/>\n                </p>\n                <input type=\"submit\" value=\"Отправить\" />\n            </form>\n        );\n      }\n    }\n    ReactDOM.render(\n        <UserForm />,\n        document.getElementById(\"app\")\n    )\n    </script>\n</body>\n</html>\n```\nОпределенный здесь компонент UserForm представляет форму для ввода имени пользователя с возможностью условной отправки.\n\nЧтобы контролировать введенные значения, в конструкторе устанавливается объект state:\n\n```\nthis.state = {name: \"\"};\n```\nПри определении поля ввода каждое поле связывается с определенным значением в state:\n\n```\n<input type=\"text\" value={this.state.name} onChange={this.onChange} />\n```\nТак, источником значения для поля ввода имени является объект this.state.name.\n\nДля отслеживания изменений в поле ввода нам надо определить обработчик для события change с помощью атрибута onChange. Этот обработчик будет срабатывать при каждом нажатии клавиши клавиатуры. Если мы не определим для поля подобный обработчик, то это поле ввода будет доступно только для чтения.\n\nСуть каждого обработчика заключается в изменении значений в this.state:\n\n```\nonChange(e) {\n    var val = e.target.value;\n    this.setState({name: val});\n}\n```\nС помощью e.target.value получаем введенное значение. После обновления новое значение this.state.name отобразится в поле ввода.\n\nДля условной отправки устанавливаем обработчик у формы для события submit, который выводит в окне введенные значения.\n\nФормы в React\n\n![] (https://metanit.com/web/react/pics/3.4.png \"результат в браузере\") *результат в браузере*"
  },
  {
    "name": "Хук useState",
    "isPractice": false,
    "index": 13,
    "description": "Хук useState",
    "content": "Одним из наиболее используемых встроенных хуков является useState, который позволяет определить состояние компонента. Например, определим простейший компонент, который применяет этот хук:\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>METANIT.COM</title>\n</head>\n<body>\n    <div id=\"app\"></div>\n        \n    <script crossorigin src=\"https://unpkg.com/react@17/umd/react.production.min.js\"></script>\n    <script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.production.min.js\"></script>\n    <script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"></script>\n    <script type=\"text/babel\">\n     \n    function Counter() {\n      const [count, setCount] = React.useState(0);\n      return (\n        <div>\n          <h3>Count = {count}</h3>\n          <button onClick={() => setCount(count + 1)}>\n            Увеличить\n          </button>\n        </div>\n      );\n    }\n           \n    ReactDOM.render(\n        <Counter />,\n        document.getElementById(\"app\")\n    )\n    </script>\n</body>\n</html>\n```\nИтак, здесь определен компонент Counter, причем определен в виде функции, так как мы не можем использовать хуки в классах-компонентах.\n\nВначале определяем переменные состояния:\n\n```\nconst [count, setCount] = React.useState(0);\n```\nВ данном случае определяются две переменных: count и setCount. Переменная count собственно хранит состояние - некоторый объект, а переменная setCount представляет функцию, которая позволяет изменять значение переменной count.\n\nНесмотря на то, что между названиями переменных есть связь - count и setCount, однако это не более чем условность. Названия переменных могут быть вообще никак между собой не связаны.\n\nЧто за значение будет хранить переменная count? А хранит она то значение, которое передается в функцию useState() - в данном случае это число 0.\n\nЧтобы инспектировать значение переменной count, ее значение выводится в заголовке h3:\n\n```\n<h3>Count = {count}</h3>\n```\nВ коде компонента определена кнопка, которая по нажатию будет вызывать изменение значения переменной count\n\n```\nonClick={() => setCount(count + 1)}\n```\nВ данном случае применяется стрелочная функция, которая выполняет выражение setCount(count + 1), которое увеличивает значение count на единицу.\n\nВ итоге по нажатию на кнопку изменится значение переменной count:\n\n![] (https://metanit.com/web/react/pics/6.1.png)\n\nХуки hooks в React и useState\n## Определение переменных состояния\nИтак, хук useState определяет переменные состояния. Единственный аргумент хука определяет начальное значение переменной состояния. А возвращает useState() массив из двух объектов. Первый объект представляет значение состояния, а второй объект представляет функцию, которая обновляет это значение. Например, выше состояние определялось следующим образом:\n\n```\nconst [count, setCount] = React.useState(0);\n```\nВ данном случае для определения переменных применяется синтаксис декомпозиции или destructuring. Но также мы могли бы использовать и стандартный синтаксис массивов для получения значений переменных:\n\n```\nvar countStateArray= React.useState(0);\nvar count = countStateArray[0];\nvar setCount = countStateArray[1];\n```\n## Определение нескольких переменных состояния\nПри необходимости можно определять множество переменных состояния. Например:\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>METANIT.COM</title>\n</head>\n<body>\n    <div id=\"app\"></div>\n         \n    <script crossorigin src=\"https://unpkg.com/react@17/umd/react.production.min.js\"></script>\n    <script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.production.min.js\"></script>\n    <script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"></script>\n    <script type=\"text/babel\">\n      \n    function User() {\n      const [name, setName] = React.useState(\"Tom\");\n      const [age, setAge] = React.useState(36);\n       \n      return (\n        <div>\n          <h3>Имя: {name}</h3>\n          <h3>Возраст: {age}</h3>\n        </div>\n      );\n    }\n            \n    ReactDOM.render(\n        <User />,\n        document.getElementById(\"app\")\n    )\n    </script>\n</body>\n</html>\n```\nВ данном случае определены две переменных состояния: name и age.\n\n![] (https://metanit.com/web/react/pics/6.3.png)\n\nХук useState в React и определение переменных\nТакже мы можем изменять значения этих переменных. Например, добавим к предыдущему примеру изменение переменных:\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>METANIT.COM</title>\n</head>\n<>\n    <div id=\"app\"></div>\n         \n    <script crossorigin src=\"https://unpkg.com/react@17/umd/react.production.min.js\"></script>\n    <script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.production.min.js\"></script>\n    <script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"></script>\n    <script type=\"text/babel\">\n      \n    function User() {\n      const [name, setName] = React.useState(\"Tom\");\n      const [age, setAge] = React.useState(36);\n       \n      function handleNameChange(event) {    \n        setName(event.target.value);  \n     }\n       \n      function handleAgeChange(event) {    \n        setAge(event.target.value);  \n     }\n      return (\n        <div>\n          <h3>Имя: {name}</h3>\n          <h3>Возраст: {age}</h3>\n           \n          <div>\n            <p>Имя: <input type=\"text\" value={name} onChange={handleNameChange} /></p>\n            <p>Возраст: <input type=\"number\" min=\"0\" max=\"110\" value={age} onChange={handleAgeChange} /></p>\n          </div>\n        </div>\n      );\n    }\n            \n    ReactDOM.render(\n        <User />,\n        document.getElementById(\"app\")\n    )\n    </script>\n</body>\n</html>\n```\nВ данном случае для обновления значений переменных name и age в компоненте определены два поля ввода. Событие onChange каждого поля привязано к одной из функций компонента - handleAgeChange или handleNameChange. Поэтому изменение значения в каждом поле вызовет соответствующую функцию. Например, при вводе текста для имени пользователя будет вызываться функция handleNameChange():\n\n```\nfunction handleNameChange(event) {    \n    setName(event.target.value);  \n}\n```\nПо умолчанию в функцию обработки события поля ввода input передается информация о событии, из которой с помощью свойства target.value мы можем получить введенное значение и затем передать его в функцию изменения состояния: setName(event.target.value)\n![] (https://metanit.com/web/react/pics/6.4.png)\n\nHook useState в React и определение переменных\nОднако нам необязательно определять отдельные переменные для хранения состояния. Хук useState равным образом позволяет определять массивы и комплексные объекты. Например, перепишем предыдущий пример, объединив переменные в один объект:\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>METANIT.COM</title>\n</head>\n<body>\n    <div id=\"app\"></div>\n         \n    <script crossorigin src=\"https://unpkg.com/react@17/umd/react.production.min.js\"></script>\n    <script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.production.min.js\"></script>\n    <script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"></script>\n    <script type=\"text/babel\">\n      \n    function UserData() {\n      const [user, setUser] = React.useState({name:\"Tom\", age: 36});\n       \n      function handleNameChange(event) { \n        setUser({name: event.target.value, age: user.age});   \n     }\n       \n      function handleAgeChange(event) {   \n        setUser({name: user.name, age: event.target.value});   \n     }\n      return (\n        <div>\n          <h3>Имя: {user.name}</h3>\n          <h3>Возраст: {user.age}</h3>\n           \n          <div>\n            <p>Имя: <input type=\"text\" value={user.name} onChange={handleNameChange} /></p>\n            <p>Возраст: <input type=\"number\" min=\"0\" max=\"110\" value={user.age} onChange={handleAgeChange} /></p>\n          </div>\n        </div>\n      );\n    }\n            \n    ReactDOM.render(\n        <UserData />,\n        document.getElementById(\"app\")\n    )\n    </script>\n</body>\n</html>\n```\nЗдесь состояние компонента представлено сложным объектом, который имеет два свойства: name и age. Но в данном случае при обновлении следует учитывать, что функция обновления (в данном случае - setUser) полностью изменяет хранимое значение состояния, поэтому нам надо полностью переопределить его свойства:\n\n```\nsetUser({name: event.target.value, age: user.age});\n```\nВ итоге мы получим тот же результат:\n![] (https://metanit.com/web/react/pics/6.4.png)\n\nHook useState в React и определение переменных\nОднако если у нас объект имеет множество свойств, то перечисление всех свойств и их значений может быть утомительным. И в этом случае мы можем сократить запись с помощью spread-оператора ...:\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>METANIT.COM</title>\n</head>\n<body>\n    <div id=\"app\"></div>\n         \n    <script crossorigin src=\"https://unpkg.com/react@17/umd/react.production.min.js\"></script>\n    <script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.production.min.js\"></script>\n    <script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"></script>\n    <script type=\"text/babel\">\n      \n    function UserData() {\n      const [user, setUser] = React.useState({name:\"Tom\", age: 36});\n       \n      function handleNameChange(event) { \n        setUser({...user, name: event.target.value});   \n     }\n       \n      function handleAgeChange(event) {   \n        setUser({...user, age: event.target.value});   \n     }\n      return (\n        <div>\n          <h3>Имя: {user.name}</h3>\n          <h3>Возраст: {user.age}</h3>\n           \n          <div>\n            <p>Имя: <input type=\"text\" value={user.name} onChange={handleNameChange} /></p>\n            <p>Возраст: <input type=\"number\" min=\"0\" max=\"110\" value={user.age} onChange={handleAgeChange} /></p>\n          </div>\n        </div>\n      );\n    }\n            \n    ReactDOM.render(\n        <UserData />,\n        document.getElementById(\"app\")\n    )\n    </script>\n</body>\n</html>\n```"
  },
  {
    "name": "Хук useEffect",
    "isPractice": false,
    "index": 14,
    "description": "Хук useEffect",
    "content": "Хук useEffect позволяет управлять различными сопутствующими действиями в функциональном компоненте или то, что называется \"side effects\" (побочные эффекты), например, извлечение данных, ручное изменение структуры DOM, использование таймеров, логгирование и т.д.. То есть в useEffect выполняет те действия, которые мы не можем выполнить в основной части функционального компонента. Этот хук фактически служит той же цели, что методы жизненного цикла componentDidMount, componentDidUpdate и componentWillUnmount в классах-компонентах.\n\nВ качестве параметра в useEffect() передается функция. При вызове хука useEffect по сути определяется \"эффект\", который затем применяется в приложении. Когда именно применяется? По умолчанию React применяет эффект после каждого рендеринга, в том числе при первом рендеринге приложения. Причем поскольку подобные эффекты определены внутри компонента, они имеют доступ к объекту props и к состоянию компонента.\n\nНапример, изменение структуры DOM через useEffect:\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>METANIT.COM</title>\n</head>\n<body>\n    <div id=\"app\"></div>\n         \n    <script crossorigin src=\"https://unpkg.com/react@17/umd/react.production.min.js\"></script>\n    <script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.production.min.js\"></script>\n    <script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"></script>\n    <script type=\"text/babel\">\n      \n    function User() {\n      const [name, setName] = React.useState(\"Tom\");\n       \n      React.useEffect(() => {    \n        // Изменяем заголовок html-страницы   \n        document.title = `Привет ${name}`;  \n      });\n       \n       \n      function changeName(event) { \n        setName(event.target.value);  \n     }\n      return (\n        <div>\n          <h3>Имя: {name}</h3>\n           \n          <div>\n            <p>Имя: <input type=\"text\" value={name} onChange={changeName} /></p>\n          </div>\n        </div>\n      );\n    }\n            \n    ReactDOM.render(\n        <User />,\n        document.getElementById(\"app\")\n    )\n    </script>\n</body>\n</html>\n```\nЗдесь мы определяем эффект, который изменяет заголовок страницы. Причем в заголовок выводится значение переменной состояния - переменной name. То есть при загрузке страницы мы увидим в ее заголовке \"Привет Tom\".\n\nОднако поскольку при вводе в текстовое поле мы изменяем значение в переменной name, и соответственно React будет выполнять перерендеринг приложения, то одновременно с этим будет изменяться и заголовок страницы:\n![] (https://metanit.com/web/react/pics/6.5.png)\n\nХук useEffect и изменение DOM в React\n## Ограничение применения эффекта\nПо умолчанию эффект выполняется при каждом повторном рендеринге на веб-странице, однако мы можем указать, чтобы React не применял эффект, если определенные значения не изменились между с момента последнего рендеринга. Для этого в useEffect в качестве необязательного параметра передается массив аргументов.\n\nСначала рассмотрим саму проблему применения эффекта. Допустим у нас есть следующая страница:\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>METANIT.COM</title>\n</head>\n<body>\n    <div id=\"app\"></div>\n          \n    <script crossorigin src=\"https://unpkg.com/react@17/umd/react.production.min.js\"></script>\n    <script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.production.min.js\"></script>\n    <script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"></script>\n    <script type=\"text/babel\">\n       \n    function User() {\n      const [name, setName] = React.useState(\"Tom\");\n      const [age, setAge] = React.useState(36);\n        \n      React.useEffect(() => {    \n        // Изменяем заголовок html-страницы   \n        document.title = `Привет ${name}`;  \n        console.log(\"useEffect\");\n      });\n        \n      const changeName = (event) => setName(event.target.value);\n      const changeAge =(event) => setAge(event.target.value);\n       \n      return (\n        <div>\n          <h3>Имя: {name}</h3>\n          <h3>Возраст: {age}</h3>\n            \n          <div>\n            <p>Имя: <input type=\"text\" value={name} onChange={changeName} /></p>\n            <p>Возраст: <input type=\"number\" value={age} onChange={changeAge} /></p>\n          </div>\n        </div>\n      );\n    }\n             \n    ReactDOM.render(\n        <User />,\n        document.getElementById(\"app\")\n    )\n    </script>\n</body>\n</html>\n```\nВ данном случае в компоненте определены две переменных состояния: name и age. При этом эффект использует только переменную name. Однако даже если переменная name останется без изменений, но переменная age будет изменена, в этом случае эффект будет повторно срабатывать:\n\n![] (https://metanit.com/web/react/pics/6.6.png)\n\nuseEffect в React и ограничение\nЭто не самое желательное поведение, в котором нет никакого смысла. И чтобы указать, что эффект применяется только при изменении переменной name, передадим ее в качестве необязательного параметра в функцию useEffect:\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>METANIT.COM</title>\n</head>\n<body>\n    <div id=\"app\"></div>\n          \n    <script crossorigin src=\"https://unpkg.com/react@17/umd/react.production.min.js\"></script>\n    <script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.production.min.js\"></script>\n    <script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"></script>\n    <script type=\"text/babel\">\n       \n    function User() {\n      const [name, setName] = React.useState(\"Tom\");\n      const [age, setAge] = React.useState(36);\n        \n      React.useEffect(() => {    \n        // Изменяем заголовок html-страницы   \n        document.title = `Привет ${name}`;  \n        console.log(\"useEffect\");\n      },\n      [name]); // эффект срабатывает только при изменении name\n        \n      const changeName = (event) => setName(event.target.value);\n      const changeAge =(event) => setAge(event.target.value);\n       \n      return (\n        <div>\n          <h3>Имя: {name}</h3>\n          <h3>Возраст: {age}</h3>\n            \n          <div>\n            <p>Имя: <input type=\"text\" value={name} onChange={changeName} /></p>\n            <p>Возраст: <input type=\"number\" value={age} onChange={changeAge} /></p>\n          </div>\n        </div>\n      );\n    }\n             \n    ReactDOM.render(\n        <User />,\n        document.getElementById(\"app\")\n    )\n    </script>\n</body>\n</html>\n```\nЕсли мы хотим, чтобы эффект вызывался только один раз при самом первом рендеринге, то в качестве параметра передаются пустые квадратные скобки - [].\n\n```\nReact.useEffect(() => {    \n    // Изменяем заголовок html-страницы   \n    document.title = `Привет ${name}`;  \n    console.log(\"useEffect\");\n},\n[]); // эффект срабатывает только один раз - при самом первом рендеринге\n```\n## Очистка ресурсов\nНередко в приложении возникает необходимость подисывается на различные ресурсы, а после окончания работы и отписываться от них. В этом случае мы можем использовать специальную форму хука useEffect():\n\n```\nuseEffect(() => {\n  // код подписки на ресурс\n  return () => {\n    // код отписки от ресурса\n  };\n});\n```\nВ начале функции хука идет подписка на ресурс, а далее оператор return возвращает функцию, которая выполняет отписку от ресурса.\n\nВ качестве примера используем подписку/отписку на событие кнопки:\n\n```\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>METANIT.COM</title>\n</head>\n<body>\n    <div id=\"app\"></div>\n    <button id=\"unmountBtn\">Unmount</button>\n     \n    <script crossorigin src=\"https://unpkg.com/react@17/umd/react.production.min.js\"></script>\n    <script crossorigin src=\"https://unpkg.com/react-dom@17/umd/react-dom.production.min.js\"></script>\n    <script src=\"https://unpkg.com/@babel/standalone/babel.min.js\"></script>\n    <script type=\"text/babel\">\n       \n    const appRoot = document.getElementById(\"app\");\n     \n    function User() {\n      const [name, setName] = React.useState(\"Tom\");\n       \n      const unmount = () => {\n          ReactDOM.unmountComponentAtNode(appRoot);\n      }\n      React.useEffect(() => {    \n       \n        const unmountBtn = document.getElementById(\"unmountBtn\");\n         \n         // подписываемся на событие onclick кнопки unmountBtn\n         unmountBtn.addEventListener(\"click\", unmount);\n         console.log(\"EventListener added\");\n          \n        return()=>{\n             // отписываемся от события\n            unmountBtn.removeEventListener(\"click\", unmount);\n            console.log(\"EventListener removed\");\n        }\n      },\n      []); // эффект срабатывает только один раз - при самом первом рендеринге\n       \n      return (<div>\n        <h3>Имя: {name}</h3>\n        <p>Имя: <input type=\"text\" value={name} onChange={(e) => setName(e.target.value)} /></p>\n        </div>);\n    }\n             \n    ReactDOM.render(\n        <User />,\n        document.getElementById(\"app\")\n    )\n    </script>\n</body>\n</html>\n```\nИтак, на странице определеная кнопка с id=unmountBtn, на событие которой мы будем подписываться. В качестве действия, которое будет выполнять кнопка, в компоненте User определена функция unmount(), которая удаляет данный компонент с веб-страницы:\n\n```\nReactDOM.unmountComponentAtNode(appRoot);\n```\nВ хуке useEffect сначала подписываемся на событие \"click\" кнопки (то есть на событие нажатия):\n\n```\nunmountBtn.addEventListener(\"click\", unmount);\n```\nОператор return возвращает функцию, которая выполняет отписку от события:\n\n```\nunmountBtn.removeEventListener(\"click\", unmount);\n```\nИ теперь важный момент: хук useEffect в данном случае будет срабатывать один раз - при самом первом рендеринге приложения - для этого в функцию в качестве необязательного параметра передается пустой массив. И соответственно функция очистки ресурсов, которая возвращаается оператором return будет выполняться один раз - при удалении компонента с веб-страницы.\n\n```\nReact.useEffect(() => {    \n        //............................\n        return()=>{\n            //.................\n        }\n      },\n      []);  // пустой массив - хук выполняется один раз\n```\nТо есть получится следущее: при загрузке компонент подисывается на событие кнопки. По нажатию на кнопку удаляется компонент. При удалении в хуке происходит удаление подписки - она нам больше не нужна, так как компонент уже удален.\n\n![] (https://metanit.com/web/react/pics/6.7.png)"
  },
  {
    "name": "Практика создание часов",
    "isPractice": true,
    "index": 15,
    "description": "Практика создание часов",
    "content": "Практика создание часов.\n\nЗадача создать часы. При старте страницы часы начинают показывать настоящее время в формате чч:мм.\n\n![] (https://ru.reactjs.org/c158617ed7cc0eac8f58330e49e48224/granular-dom-updates.gif \"Пример работы\")*Пример работы*\n\nВаш результат запакуйте в архив и отправьте на проверку."
  },
  {
    "name": "Заминка",
    "isPractice": false,
    "index": 16,
    "description": "Заминка",
    "content": "Спасибо что уделили внимание курсу.\n\nВот что можно учить дальше: \n* [metanit.com] (https://metanit.com/ )\n* [документация] (https://ru.reactjs.org/)\n* [полезные ролики по react.js] (https://www.youtube.com/watch?v=xJZa2_aldDs)"
  }
]